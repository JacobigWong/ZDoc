class Zog{
private:
	static const int m_nBufLen = 1024;
public:
	static void DBGWrite(char *fmt,...)
	{
		static HANDLE	hDbgFile = INVALID_HANDLE_VALUE;

		if (hDbgFile == INVALID_HANDLE_VALUE) {
			char cFileName[MAX_PATH] = {0};
			CTime time = CTime::GetCurrentTime();
			sprintf_s(cFileName,MAX_PATH,"c:\\Log.z_%04d%02d%02d_%02d%02d%02d_A.Log",time.GetYear(),time.GetMonth(),time.GetDay(),time.GetHour(),time.GetMinute(),time.GetSecond());
			hDbgFile = ::CreateFileA(cFileName,
				GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, 0);
		}

		static char buf[m_nBufLen] = {0};

		SYSTEMTIME st;
		GetLocalTime(&st);

		DWORD nCurLen = _snprintf_s(buf,m_nBufLen, _TRUNCATE,"[%08x] %02d-%02d %02d:%02d:%02d.%03d # ",(unsigned) GetCurrentThreadId(),st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond,st.wMilliseconds);

		va_list	va;
		va_start(va, fmt);
		//z wvsprintf 不支持浮点数
		nCurLen += _vsnprintf_s(buf + nCurLen,m_nBufLen-nCurLen,_TRUNCATE,fmt,va);
		va_end(va);
		::WriteFile(hDbgFile, buf, nCurLen, &nCurLen, 0);
	}

	static void DBGWriteW(TCHAR *fmt,...)
	{
		static HANDLE	hDbgFile = INVALID_HANDLE_VALUE;

		if (hDbgFile == INVALID_HANDLE_VALUE) {
			TCHAR szFileName[MAX_PATH] = {0};
			CTime time = CTime::GetCurrentTime();
			//z swprintf_s
			_stprintf_s(szFileName,MAX_PATH,_T("c:\\Log.z_%04d%02d%02d_%02d%02d%02d_W.Log"),time.GetYear(),time.GetMonth(),time.GetDay(),time.GetHour(),time.GetMinute(),time.GetSecond());

			hDbgFile = ::CreateFile(szFileName,
				GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, 0);

			if (sizeof(TCHAR) == sizeof(WCHAR))
			{
				DWORD	len = 2;
				::WriteFile(hDbgFile, "\xff\xfe", len, &len, 0);
			}
		}

		static TCHAR buf[m_nBufLen] = {0};
		SYSTEMTIME st;

		GetLocalTime(&st);

		//z _snwprintf_s
		DWORD nCurLen = _sntprintf_s(buf,m_nBufLen, _TRUNCATE,_T("[%08x] %02d-%02d %02d:%02d:%02d.%03d # "),(unsigned) GetCurrentThreadId(),st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond,st.wMilliseconds);

		va_list	va;
		va_start(va, fmt);
		//z _vsnwprintf_s
		nCurLen += _vsntprintf_s(buf+nCurLen,m_nBufLen-nCurLen,_TRUNCATE, fmt, va);
		va_end(va);
		::WriteFile(hDbgFile, buf, nCurLen * 2, &nCurLen, 0);
	}
};

class ZTimer
{
public:
    ZTimer()
    {
        Init();
    }

    explicit ZTimer(const TCHAR* desc)
    {
        Init();
        if (desc != NULL)
        {
            _tcscpy_s(_desc, desc);
        }
    }

    void Reset()
    {
        ++_resetCnt;
        QueryPerformanceCounter(&_startCount);
    }

    double Elapsed()
    {
        return Elapsed(NULL);
    }

    double Elapsed(const TCHAR* subDesc)
    {
        QueryPerformanceCounter(&_endCount);
        double fElapsedTime = (_endCount.QuadPart - _startCount.QuadPart) * 1000.0 / _frequency.QuadPart;
        TCHAR cBuff[256] = { 0 };
        if (subDesc == NULL)
        {
            _stprintf_s(cBuff, _T("Elapsed %s.T#%-2d.T1#%-2d: %.3f\r\n"), _desc, _cnt++, _resetCnt, fElapsedTime);
        }
        else
        {
            _stprintf_s(cBuff, _T("Elapsed %s.%s T#%-2d.T1#%-2d: %.3f\r\n"), _desc, subDesc, _cnt++, _resetCnt, fElapsedTime);
        }

        //z Zog::DBGWriteW(cBuff);
        OutputDebugString(cBuff);

        return fElapsedTime;
    }

    ~ZTimer()
    {
        Elapsed();
    }

private:
    void Init()
    {
        memset(_desc, 0, sizeof(_desc));
        _startCount.QuadPart = 0;
        _endCount.QuadPart = 0;
        _cnt = 0;
        _resetCnt = 0;
        QueryPerformanceFrequency(&_frequency);
        QueryPerformanceCounter(&_startCount);
    }

    ZTimer(ZTimer const&);
    ZTimer& operator=(ZTimer const&);

private:
    LARGE_INTEGER _frequency;
    LARGE_INTEGER _startCount;
    LARGE_INTEGER _endCount;
    TCHAR _desc[64];
    int _cnt;
    int _resetCnt;
};

class ZLogger
{
public:
	//z gnu log level : DEBUG < INFO < WARN < TRACE < ERROR < ALERT < CRIT < FATAL < EMERG
	enum LOG_LEVEL { kInfo, kWarning, kError };
	enum LOG_TYPE { kDbgwin = 0x01,kFile=0x02};

public:
	static bool Log(LPCTSTR tszFormatString, ...)
	{
		bool bReturn;
		va_list  Arguments;

		va_start(Arguments, tszFormatString);
		bReturn = LogVA(kInfo, tszFormatString, Arguments);
		va_end(Arguments);

		return bReturn;
	}

	static bool Log(DWORD dwLogCode, LPCTSTR tszFormatString, ...)
	{
		bool bReturn;
		va_list  Arguments;

		va_start(Arguments, tszFormatString);
		bReturn = LogVA(dwLogCode, tszFormatString, Arguments);
		va_end(Arguments);

		return bReturn;
	}

private:
	static bool LogVA(LPCTSTR tszFormatString, va_list Arguments)
	{
		return LogVA(kInfo, tszFormatString, Arguments);
	}

	static int LogTime(TCHAR* pBuff,const int nBufLen)
	{
		SYSTEMTIME st;
		GetLocalTime(&st);

		return _sntprintf_s(pBuff,nBufLen, _TRUNCATE,_T(" %02d-%02d %02d:%02d:%02d.%3d # "),st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond,st.wMilliseconds);
	}

	static bool LogVA(DWORD dwLogCode, LPCTSTR tszFormatString, va_list Arguments)
	{
		TCHAR logMessage[LOG_LENGTH] = { 0 };
		int nLevelLength = _snwprintf_s(logMessage, LOG_LENGTH, _TRUNCATE, _T("%s"), GetLogLevelDesc(dwLogCode));
		nLevelLength += LogTime(logMessage+nLevelLength,LOG_LENGTH - nLevelLength);
		int nLogLength = _vsnwprintf_s(logMessage + nLevelLength, LOG_LENGTH - nLevelLength, _TRUNCATE, tszFormatString, Arguments);

		//z exceed LOG_LENGTH
		if (nLogLength == -1)
		{
		}
		OutputDebugString(logMessage);

		return true;
	}

	static LPCTSTR GetLogLevelDesc(DWORD dwLogCode)
	{
		switch (dwLogCode)
		{
		case kInfo:
			return _T("Info    : ");
			break;
		case kWarning:
			return _T("Warning : ");
			break;
		case kError:
			return _T("Error   : ");
			break;
		default:
			return _T("Other   : ");
		}
	}
	static const int LOG_LENGTH = 1024;

private:
	ZLogger(void) {}
	~ZLogger(void) {}

	ZLogger(ZLogger const&);
	ZLogger& operator=(ZLogger const&);

public:
#define ZLogger_Level(dwLogCode,log_fmt, ...) \
	do{	\
	char logHeader[1024] = {0}; \
	_snprintf_s(logHeader,sizeof(logHeader),sizeof(logHeader),"[%s:%d][%s]",__FILE__, __LINE__, __FUNCTION__); \
	OutputDebugStringA(logHeader); \
	ZLogger::Log(dwLogCode,_T("") log_fmt _T("\n"),##__VA_ARGS__);\
	}while(0)

#define ZLogger_Trace(log_fmt, ...) ZLogger_Level(ZLogger::kInfo,log_fmt,##__VA_ARGS__)
#define ZLogger_Warning(log_fmt, ...) ZLogger_Level(ZLogger::kWarning,log_fmt,##__VA_ARGS__)
#define ZLogger_Error(log_fmt, ...) ZLogger_Level(ZLogger::kError,log_fmt,##__VA_ARGS__)
};

class ZTimer
{
public:
	ZTimer()
	{
		Init();
	}

	explicit ZTimer(const TCHAR* desc)
	{
		Init();
		if (desc != NULL)
		{
			_tcscpy_s(_desc, desc);
		}
	}

	void Reset()
	{
		++_resetCnt;
		QueryPerformanceCounter(&_startCount);
	}

	double Elapsed()
	{
		return Elapsed(NULL);
	}

	double Elapsed(const TCHAR* subDesc)
	{
		QueryPerformanceCounter(&_endCount);
		double fElapsedTime = (_endCount.QuadPart - _startCount.QuadPart) * 1000.0 / _frequency.QuadPart;
		TCHAR cBuff[256] = { 0 };
		if (subDesc == NULL)
		{
			_stprintf_s(cBuff, _T("Elapsed %s.T#%-2d.T1#%-2d: %.3f\r\n"), _desc, _cnt++, _resetCnt, fElapsedTime);
		}
		else
		{
			_stprintf_s(cBuff, _T("Elapsed %s.%s T#%-2d.T1#%-2d: %.3f\r\n"), _desc, subDesc, _cnt++, _resetCnt, fElapsedTime);
		}
		
		Zog::DBGWriteW(cBuff);
		//z OutputDebugString(cBuff);

		return fElapsedTime;
	}

	~ZTimer()
	{
		Elapsed();
	}

private:
	void Init()
	{
		memset(_desc, 0, sizeof(_desc));
		_startCount.QuadPart = 0;
		_endCount.QuadPart = 0;
		_cnt = 0;
		_resetCnt = 0;
		QueryPerformanceFrequency(&_frequency);
		QueryPerformanceCounter(&_startCount);
	}

	ZTimer(ZTimer const&);
	ZTimer& operator=(ZTimer const&);

private:
	LARGE_INTEGER _frequency;
	LARGE_INTEGER _startCount;
	LARGE_INTEGER _endCount;
	TCHAR _desc[64];
	int _cnt;
	int _resetCnt;
};

// h
#include <DbgHelp.h>  
#pragma comment(lib, "dbghelp.lib")
typedef USHORT (WINAPI *CaptureStackBackTraceType)(__in ULONG, __in ULONG, __out PVOID*, __out_opt PULONG);

void printStack(void);

// cpp
CaptureStackBackTraceType pfCaptureStackBackTrace = (CaptureStackBackTraceType)(GetProcAddress(LoadLibrary(_T("kernel32.dll")), "RtlCaptureStackBackTrace"));

void printStack(void)
{  
	char cBuff[1024] = {0};  
	unsigned int   i;  
	void         * stack[128];  
	unsigned short frames;  
	SYMBOL_INFO  * symbol;  
	HANDLE         process;  

	process = GetCurrentProcess();  

	SymInitialize(process, NULL, TRUE);  

	frames = pfCaptureStackBackTrace(0, 128, stack, NULL);  
	symbol = (SYMBOL_INFO *)calloc(sizeof(SYMBOL_INFO) + 256 * sizeof(char), 1);  
	symbol->MaxNameLen = 255;  
	symbol->SizeOfStruct = sizeof(SYMBOL_INFO);  

	OutputDebugString(_T("##########################################################################\n"));  
	for (i = 0; i < frames; i++)  
	{  
		SymFromAddr(process, (DWORD64)(stack[i]), 0, symbol);  
		sprintf_s(cBuff,1024,("%i: %s - 0x%0X\n"),frames - i - 1, symbol->Name, symbol->Address);  
		OutputDebugStringA(cBuff);  
	}  
	OutputDebugString(_T("__________________________________________________________________________\n"));  

	free(symbol);
}

// ----
#define D3D_DEBUG_INFO
To enable debug information, the #define must get built before the D3D9.h file 

Use the Call Stack for Extended Debug

With Direct3D debug enabled, you can also look at a call stack each time an object is created. This will make your application very slow, but can be used to check for resource leaks. To write out the call stack, set the following registry key to 1:

\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Direct3D\\
D3D9Debugging\\EnableCreationStack

Building your application with debug enabled will give you access to this additional variable:
LPCWSTR CreationCallStack;

This variable will store the call stack each time that an object is created. This will make your application very slow, but can be used to debug resource leaks.
// ---

使用 /d2Zi+ 或 /Zo 
Enable /d2Zi+ when building with Visual Studio 2013 ...
Add "d2Zi+"/"Zo" compiler flag to debug optimized code

// --- 
